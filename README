Brett Hillyard, Annie Le Piere
CSC453 Project 4

Our file system is designed so that the files are stored contigiously in memory. We do so utilizing a bitmap to keep track of the blocks unallocated for file data. When choosing a block the bitmap can find a block that has a certain amount of free blocks directly after it in memory so when we designate these blocks in memory for the file, they are located sequentially.
This allows us to have faster lookup times because file data can be indexed faster due to not having to map to different blocks of a file tha are not stored sequentially in memory. This comes at the tradeoff of external fragmentation as when files get deleted there creates a gap in the file system that may be too small for the next file to fit in resulting in unused memory blocks. However, when we do decide which blocks of memory can contigiously store data for a file we start at the beginning of the open file block list and keep looking from free block index 0 (which is the 2nd block on the disk) outward so potentially the external fragmentation can be filled with new data blocks if files are created that are smaller than the ones previously deleted. For the open file descriptor table we chose to use a linked list so that we can keep track of the files opened on our file system. The linked list may not be the fastest way to look and see if a file is open on our file system, but it is a relatively simple design choice that allows us to easily store and look through all the open file descriptors.

The additional features we added were Timestamps, Directory listing and file renaming. We implemented timestamps when opening a file. This initializes creation time, modification time, and access time. We use the localtime() function. We break up the time into bytes and write those into the inode byte by byte, after the metadata that is normally stored in the inodes. So later, we can call a function to list off the creation, modification, and access times by indexing to their respective indices in the inode, reading the bytes, and reformatting. After initialization, modification time is updates when writing to a file and access time is updated when opening a file.

Directory listing and file renaming was the second additional feature we added. To do this, we looped through every inode in the root directory block, and for each inode we read in the filename (stopping at the null character) and printed out each filename.
